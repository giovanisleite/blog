---
slug: 'erros-comuns-com-react-testing-library'
title: 'Erros comuns com React Testing Library [Tradução]'
date: '2021-04-24'
author: 'Kent C. Dodds'
description:
  '_Alguns erros que eu vejo frequentemente ao utilizarem a React Testing Library._ Imagem de [Sarah Kilian](https://unsplash.com/photos/52jRtc2S_VE)'
tags:
 - react
 - tradução
keywords:
  - 'react'
  - 'testing'
  - 'react testing library'
  - 'dom testing library'
  - 'async'
banner: './images/banner.jpg'
---

[Artigo original em Inglês](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library)

Olá 👋 Eu criei a biblioteca React Testing porque eu não estava satisfeito com o cenário de testes naquele momento. Ela se expandiu para a DOM Testing Library e agora nós temos implementações da Testing Library (wrappers) para todos frameworks JavaScript populares e ferramenta de teste que focam no DOM (e até algumas que não).


Com o passar do tempo, nós fizemos algumas pequenas mudanças na API e nós descobrimos alguns padrões subótimos. Apesar dos nossos esforços para documentar a "melhor forma" de usar as ferramentas que nós fornecemos, eu ainda vejo blog posts e testes escritos seguindo esses padrões subótimos e eu gostaria de passar por cada um deles, comentar o porquê de não serem ótimos e como você pode melhorar seus testes para evitar essas armadilhas.

> Nota: Eu clasifiquei cada um desses pela importância:
>
> - baixa: isso é majoritariamente opinião minha, sinta-se a vontade para ignorar e você provavelmente não vai ter problemas
> - média: talvez você encontre alguns bugs, perca confiança, ou tenha trabalho extra desnecessariamente
> - alta: escute esse conselho! Você provavelmente está perdendo confiança ou terá testes problemáticos

<br/>

## Não usar os plugins para ESLint da Testing Library

> Importância: média

Se você quer evitar vários desses erros comuns, então os plugins oficiais para ESLint podem te ajudar bastante:

- [eslint-plugin-testing-library](https://github.com/testing-library/eslint-plugin-testing-library)
- [eslint-plugin-jest-dom](https://github.com/testing-library/eslint-plugin-jest-dom)

**Conselho: Instale e use os plugins para ESLint data Testing Library**

<br />

## Usar `wrapper` como nome para a variável que recebe o retorno de `render`

> Importância: baixa

```javascript
// ❌
const wrapper = render(<Example prop="1" />)
wrapper.rerender(<Example prop="2" />)

// ✅
const {rerender} = render(<Example prop="1" />)
rerender(<Example prop="2" />)
```

O nome `wrapper` é velharia herdada do `enzyme` e nós não precisamos disso aqui. O valor retornado de `render` não está "wrapping" nada. É simplesmente uma coleção de utilidades que (graças ao próximo item) você realmente não deveria precisar com frequência de qualquer forma.

**Conselho: desestruture o que você precisar do retorno do `render` ou chame de `view`.**

<br />

## Usar `cleanup`

> Importância: média

```javascript
// ❌
import {render, screen, cleanup} from '@testing-library/react'

afterEach(cleanup)

// ✅
import {render, screen} from '@testing-library/react'
```

Já faz bastante tempo que `cleanup` acontece automaticamente (com suporte na maioria dos grandes frameworks de teste) e você não precisa se preocupar com isso.
[Saiba mais](https://testing-library.com/docs/react-testing-library/api#cleanup).

**Conselho: não use `cleanup`**

<br />

## Não usar screen

> Importância: média

```javascript
// ❌
const {getByRole} = render(<Example />)
const errorMessageNode = getByRole('alert')

// ✅
render(<Example />)
const errorMessageNode = screen.getByRole('alert')
```

`screen` [foi adicionado na versão v6.11.0 da DOM Testing Library](https://github.com/testing-library/dom-testing-library/releases/tag/v6.11.0) (o que significa que você deveria ter acesso a ela em qualquer ambiente com `@testing-library/react@>=9`). Ela vem do mesmo import que você recebe `render`:

```javascript
import {render, screen} from '@testing-library/react'
```

O benefício de utilizar `screen` é que você não precisa ficar mudando o que você recebe do `render` conforme queira adicionar/remover as queries que você precisa. Você só precisa digitar `screen.` e deixar a mágica do autocomplete do seu editor cuidar do resto.

A única exceção para isso é se você está usando o `container` ou `baseElement` que você provavelmente deveria evitar (eu honestamente não consigo mais pensar em um caso de uso legítimo para essas opções e elas só existem por razões históricas neste momento)

Você também pode usar [`screen.debug`](https://testing-library.com/docs/dom-testing-library/api-queries#screendebug) ao invés de `debug`

**Conselho: use `screen` para fazer as queries e usar o debug.**

<br />

## Usar a asserção (assertion) errada

> Importância: alta

```javascript
const button = screen.getByRole('button', {name: /disabled button/i})

// ❌
expect(button.disabled).toBe(true)
// Mensagem de erro:
//  expect(received).toBe(expected) // Object.is equality
//
//  Expected: true
//  Received: false

// ✅
expect(button).toBeDisabled()
// Mensagem de erro:
//   Received element is not disabled:
//     <button />
```

Aquela asserção `toBeDisabled` vem da [`jest-dom`](https://github.com/testing-library/jest-dom). É fortemente recomendado o uso da `jest-dom` pois as mensagens de erro são muito melhores.

**Conselho: instale e use

<br />
[`@testing-library/jest-dom`](https://github.com/testing-library/jest-dom#tobedisabled)**

## Colocar `act` em volta das coisas desnecessariamente

> Importância: média

```javascript
// ❌
act(() => {
  render(<Example />)
})

const input = screen.getByRole('textbox', {name: /choose a fruit/i})
act(() => {
  fireEvent.keyDown(input, {key: 'ArrowDown'})
})

// ✅
render(<Example />)
const input = screen.getByRole('textbox', {name: /choose a fruit/i})
fireEvent.keyDown(input, {key: 'ArrowDown'})
```

Eu vejo pessoas colocando `act` em volta de coisas como essas porque elas veem esses warnings com `act` o tempo todo e estão apenas tentando desesperadamente fazer com que eles desapareçam, mas o que eles não sabem é que `render` e `fireEvent` já estão envolvidos por `act`! Então aqueles ali que elas colocam em volta não está fazendo nada útil.

Na maioria das vezes, se você está vendo um warning com `act`, não é algo pra só ignorar ou tentar fazer desaparecer, na verdade isso está te avisando que algo inesperado está acontecendo com seu teste. Você pode aprender mais sobre isso com o meu blog post (e vídeos): [Corrija o warning "not wrapped in act(...)"](https://kentcdodds.com/blog/fix-the-not-wrapped-in-act-warning).

**Conselho: Aprenda quando `act` é necessário e não coloque `act` em volta das coisas desnecessariamente.**

<br />

## Usar a query errada

> Importância: alta

```javascript
// ❌
// Assumindo que você está trabalhando em cima desse DOM:
// <label>Username</label><input data-testid="username" />
screen.getByTestId('username')

// ✅
// Mude o DOM para ser acessível associando a label ao input e informando o tipo do input
// <label for="username">Username</label><input id="username" type="text" />
screen.getByRole('textbox', {name: /username/i})
```

Nós mantemos uma página chamada ["Which query should I use?" (Qual query eu deveria usar?)](https://testing-library.com/docs/guide-which-query) de queries que você deveria tentar usar na ordem que você deveria tentar usar. Se o seu objetivo está alinhado com o nosso que é ter testes que tragam confiança que sua aplicação irá funcionar quando seus usuários a usarem, então você vai querer aplicar as queries no DOM o mais próximo possível da forma que o seu usuário final faz. As queries que nós fornecemos te ajudam a fazer isso, mas nem todas as queries são criadas igualmente.

### Usar `container` para fazer query por elementos

Como uma subseção de "Usar a query errada" Eu quero falar sobre usando a query diretamente no `container`.

```javascript
// ❌
const {container} = render(<Example />)
const button = container.querySelector('.btn-primary')
expect(button).toHaveTextContent(/click me/i)

// ✅
render(<Example />)
screen.getByRole('button', {name: /click me/i})
```

Nós queremos garantir que seus usuários possam interagir com a sua UI e se você fazer as queries por aí usando `querySelector` nós perdemos grande parte dessa confiança, o teste é mais difícil de ler, e vai quebrar com mais frequência. Isso está de mãos dadas com a próxima subseção:

### Não fazer a query por texto

Como uma subseção de "Usar a query errada", eu quero falar porque eu recomendo que você use a query pelo texto _verdadeiro_  (Em caso de localização, eu recomendo que use o padrão), ao invés ficar usando test IDs ou outros mecanismos em todo canto.

```javascript
// ❌
screen.getByTestId('submit-button')

// ✅
screen.getByRole('button', {name: /submit/i})
```

Se você não usa a query com o texto verdadeiro, então você tem que fazer trabalho extra para ter certeza
que suas traduções estão sendo aplicadas corretamente. A maior reclamação
que eu escuto sobre isso é que isso faz com que criadores de conteúdo quebrem seus testes. Minha
réplica a isso é que primeiro, se um criador de conteúdo troca "Username" por "Email",
essa é uma troca que eu definitivamente quero saber sobre (porque eu vou ter que mudar minha implementação).
Além disso, se há uma situação que eles quebram algo, arrumar isso não toma tanto tempo assim.
É fácil de identificar e de corrigir.

Então o custo é bem baixo, e o benefício é que você aumenta a confiança de que suas tradução estão sendo aplicadas corretamente _e_ seus testes são mais fáceis de escrever e de ler.

Vale mencionar que nem todo mundo concorda comigo nisso, fica a vontade para ler
mais sobre isso [nesse fio no twitter](https://twitter.com/kentcdodds/status/1203179007644012544).

### Não usar `*ByRole` na maior parte do tempo

Como uma subseção de "Usar a query errada" eu quero falar sobre `*ByRole`.
Nas versões recentes, as queries `*ByRole` foram seriamente melhoradas
(primeiramente graças ao grande trabalho do [Sebastian Silbermann](https://twitter.com/sebsilbermann))
e agora são as mais recomendadas para o uso nos testes dos seus componentes. Aqui estão algumas das minhas features favoritas desse tipo de query.

A opção `name` permite que você faça a query por elementos pelo seu 
["Nome acessível"](https://www.w3.org/TR/accname-1.1/) que é o que leitores de tela
irão ler ao ler o elemento _e_ funciona mesmo que seu elemento tenha o
texto dividido entre múltiplos elementos. Por exemplo:

```javascript
// Assumindo que nós temos essa estrutura de DOM para trabalhar
// <button><span>Hello</span> <span>World</span></button>

screen.getByText(/hello world/i)
// ❌ Falha com o seguinte erro:
// Unable to find an element with the text: /hello world/i. This could be
// because the text is broken up by multiple elements. In this case, you can
// provide a function for your text matcher to make your matcher more flexible.

screen.getByRole('button', {name: /hello world/i})
// ✅ works!
```

Uma razão pela qual as pessoas não usam as queries `*ByRole` é porque elas não estão familiarizadas
com os _roles_ implícitos colocado nos elementos.
[Aqui está uma lista de Roles no MDN](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles).
Outra que também é uma das minhas features favoritas das queries `*ByRole` é que se não conseguirmos
encontrar um elemento com o role que você específicou, nós vamos mostrar na tela não somente o DOM inteiro como
em caso de erros quando usado as variantes de `get*` ou `find*`, mas também iremos mostrar todos os roles disponíveis para você poder usar na query.

```javascript
// Assumindo que esse é o DOM que nós temos para trabalhar
// <button><span>Hello</span> <span>World</span></button>
screen.getByRole('blah')
```

Isso vai falhar com a seguinte mensagem de erro:

```javascript
TestingLibraryElementError: Unable to find an accessible element with the role "blah"

Here are the accessible roles:

  button:

  Name "Hello World":
  <button />

  --------------------------------------------------

<body>
  <div>
    <button>
      <span>
        Hello
      </span>

      <span>
        World
      </span>
    </button>
  </div>
</body>
```

Note que nós não tivemos que adicionar `role=button` ao nosso botão para que ele tivesse o role button.
Esse é um role implícito, o que nos leva perfeitamente ao nosso próximo... 

**Conselho: Leia e siga as recomendações do [Guia "Qual Query Eu Deveria Usar?"](https://testing-library.com/docs/guide-which-query).**

<br />

## Adicionar `aria-`, `role`, e outros atributos de acessibilidade incorretamente

> Importância: alta

```javascript
// ❌
render(<button role="button">Click me</button>)

// ✅
render(<button>Click me</button>)
```

Sair distribuindo atributos de acessibilidade sem pensar não é só desnecessário (como no
caso acima), mas também pode confundir os leitores de tela e seus usuários. Os atributos
de acessibilidade deveriam ser utilizadas apenas quando o HTML semântico não é o bastante
no seu caso de uso (como o caso de você estar desenvolvendo uma UI não-nativa que você quer
tornar acessível [como um autocomplete](https://github.com/downshift-js/downshift)). Se é
isso que você está desenvolvendo, use uma biblioteca existente que seja acessível ou siga as práticas indicadas para WAI-ARIA.
Geralmente eles tem [ótimos exemplos](https://www.w3.org/TR/wai-aria-practices/examples/accordion/accordion.html).

> Obs: para fazer `input`s acessíveis via "role" você terá que especificar o
> atributo `type`!

**Conselho: Evite adicionar atributos de acessibilidade desnecessários ou incorretos.**

<br />

## Not using `@testing-library/user-event`

> Importância: média

```javascript
// ❌
fireEvent.change(input, {target: {value: 'hello world'}})

// ✅
userEvent.type(input, 'hello world')
```

[`@testing-library/user-event`](https://github.com/testing-library/user-event)
is a package that's built on top of `fireEvent`, but it provides several methods
that resemble the user interactions more closely. In the example above,
`fireEvent.change` will simply trigger a single change event on the input.
However the `type` call, will trigger `keyDown`, `keyPress`, and `keyUp` events
for each character as well. It's much closer to the user's actual interactions.
This has the benefit of working well with libraries that you may use which don't
actually listen for the change event.

We're still working on `@testing-library/user-event` to ensure that it delivers
what it promises: firing all the same events the user would fire when performing
a specific action. I don't think we're quite there yet and this is why it's not
baked-into `@testing-library/dom` (though it may be at some point in the
future). However, I'm confident enough in it to recommend you give it a look and
use it's utilities over `fireEvent`.

**Conselho: Use `@testing-library/user-event` over `fireEvent` where possible.**

<br />

## Using `query*` variants for _anything_ except checking for non-existence

> Importância: alta

```javascript
// ❌
expect(screen.queryByRole('alert')).toBeInTheDocument()

// ✅
expect(screen.getByRole('alert')).toBeInTheDocument()
expect(screen.queryByRole('alert')).not.toBeInTheDocument()
```

The _only_ reason the `query*` variant of the queries is exposed is for you to
have a function you can call which does not throw an error if no element is
found to match the query (it returns `null` if no element is found). The _only_
reason this is useful is to verify that an element is not rendered to the page.

**Conselho: Only use the `query*` variants for asserting that an element cannot be

<br />
found.**

## Using `waitFor` to wait for elements that can be queried with `find*`

> Importância: alta

```javascript
// ❌
const submitButton = await waitFor(() =>
  screen.getByRole('button', {name: /submit/i}),
)

// ✅
const submitButton = await screen.findByRole('button', {name: /submit/i})
```

Those two bits of code are basically equivalent (`find*` queries use `waitFor`
under the hood), but the second is simpler and the error message you get will be
better.

**Conselho: use `find*` any time you want to query for something that may not be

<br />
available right away.**

## Passing an empty callback to `waitFor`

> Importância: alta

```javascript
// ❌
await waitFor(() => {})
expect(window.fetch).toHaveBeenCalledWith('foo')
expect(window.fetch).toHaveBeenCalledTimes(1)

// ✅
await waitFor(() => expect(window.fetch).toHaveBeenCalledWith('foo'))
expect(window.fetch).toHaveBeenCalledTimes(1)
```

The purpose of `waitFor` is to allow you to wait for a specific thing to happen.
If you pass an empty callback it _might_ work today because all you need to wait
for is "one tick of the event loop" thanks to the way your mocks work. But
you'll be left with a fragile test which could easily fail if you refactor your
async logic.

**Conselho: wait for a specific assertion inside `waitFor`.**

<br />

## Having multiple assertions in a single `waitFor` callback

> Importância: baixa

```javascript
// ❌
await waitFor(() => {
  expect(window.fetch).toHaveBeenCalledWith('foo')
  expect(window.fetch).toHaveBeenCalledTimes(1)
})

// ✅
await waitFor(() => expect(window.fetch).toHaveBeenCalledWith('foo'))
expect(window.fetch).toHaveBeenCalledTimes(1)
```

Let's say that for the example above, `window.fetch` was called twice. So the
`waitFor` call will fail, however, we'll have to wait for the timeout before we
see that test failure. By putting a single assertion in there, we can both wait
for the UI to settle to the state we want to assert on, and also fail faster if
one of the assertions do end up failing.

**Conselho: only put one assertion in a callback.**

<br />

## Performing side-effects in `waitFor`

> Importância: alta

```javascript
// ❌
await waitFor(() => {
  fireEvent.keyDown(input, {key: 'ArrowDown'})
  expect(screen.getAllByRole('listitem')).toHaveLength(3)
})

// ✅
fireEvent.keyDown(input, {key: 'ArrowDown'})
await waitFor(() => {
  expect(screen.getAllByRole('listitem')).toHaveLength(3)
})
```

`waitFor` is intended for things that have a non-deterministic amount of time
between the action you performed and the assertion passing. Because of this, the
callback can be called (or checked for errors) a non-deterministic number of
times and frequency (it's called both on an interval as well as when there are
DOM mutations). So this means that your side-effect could run multiple times!

This also means that you can't use snapshot assertions within `waitFor`. If you
do want to use a snapshot assertion, then first wait for a specific assertion,
and then after that you can take your snapshot.

**Conselho: put side-effects outside `waitFor` callbacks and reserve the callback

<br />
for assertions only.**

## Using `get*` variants as assertions

> Importância: baixa

```javascript
// ❌
screen.getByRole('alert', {name: /error/i})

// ✅
expect(screen.getByRole('alert', {name: /error/i})).toBeInTheDocument()
```

This one's not really a big deal actually, but I thought I'd mention it and give
my opinion on it. If `get*` queries are unsuccessful in finding the element,
they'll throw a really helpful error message that shows you the full DOM
structure (with syntax highlighting) which will help you during debugging.
Because of this, the assertion could never possibly fail (because the query will
throw before the assertion has a chance to).

For this reason, many people skip the assertion. This really is fine honestly,
but I personally normally keep the assertion in there just to communicate to
readers of the code that it's not just an old query hanging around after a
refactor but that I'm explicitly asserting that it exists.

**Conselho: If you want to assert that something exists, make that assertion

<br />
explicit.**

## Conclusion

As maintainers of the testing library family of tools, we do our best to make
APIs that lead people to use things as effectively as possible and where that
falls short we try to document things correctly. But this can be really
difficult (especially as APIs change/improve/etc). Hopefully this was helpful to
you. We really just want to make you more successful at shipping your software
with confidence.

Good luck!
