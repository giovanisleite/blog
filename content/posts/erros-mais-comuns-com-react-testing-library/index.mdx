---
slug: 'erros-comuns-com-react-testing-library'
title: 'Erros comuns com React Testing Library [Tradu√ß√£o]'
date: '2021-04-26'
author: 'Kent C. Dodds'
description:
  '_Alguns erros que eu vejo frequentemente ao utilizarem a React Testing Library._ Imagem de [Sarah Kilian](https://unsplash.com/photos/52jRtc2S_VE)'
tags:
 - react
 - tradu√ß√£o
keywords:
  - 'react'
  - 'testing'
  - 'react testing library'
  - 'dom testing library'
  - 'async'
banner: './images/banner.jpg'
---

[Artigo original (em Ingl√™s) escrito por Kent C. Dodds](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library)

Ol√° üëã Eu criei a biblioteca React Testing porque eu n√£o estava satisfeito com o cen√°rio de testes naquele momento. Ela se expandiu para a DOM Testing Library e agora n√≥s temos implementa√ß√µes da Testing Library (wrappers) e ferramenta de teste que focam no DOM (e at√© algumas que n√£o) para todos frameworks JavaScript populares.


Com o passar do tempo, n√≥s fizemos algumas pequenas mudan√ßas na API e descobrimos alguns padr√µes sub√≥timos. Apesar dos nossos esfor√ßos para documentar a "melhor forma" de usar as ferramentas que n√≥s fornecemos, eu ainda vejo blog posts e testes escritos seguindo esses padr√µes sub√≥timos e eu gostaria de passar por cada um deles, comentar o porqu√™ de n√£o serem √≥timos e como voc√™ pode melhorar seus testes para evitar essas armadilhas.

> Nota: Eu clasifiquei cada um deles pela import√¢ncia:
>
> - baixa: isso √© majoritariamente opini√£o minha, sinta-se a vontade para ignorar e voc√™ provavelmente n√£o vai ter problemas
> - m√©dia: talvez voc√™ encontre alguns bugs, perca confian√ßa, ou tenha trabalho extra desnecessariamente
> - alta: escute esse conselho! Voc√™ provavelmente est√° perdendo confian√ßa e/ou ter√° testes problem√°ticos

<br/>

## N√£o usar os plugins para ESLint da Testing Library

> Import√¢ncia: m√©dia

Se voc√™ quer evitar v√°rios destes erros comuns, ent√£o os plugins oficiais para ESLint podem te ajudar bastante:

- [eslint-plugin-testing-library](https://github.com/testing-library/eslint-plugin-testing-library)
- [eslint-plugin-jest-dom](https://github.com/testing-library/eslint-plugin-jest-dom)

**Conselho: Instale e use os plugins para ESLint da Testing Library**

<br />

## Usar `wrapper` como nome da vari√°vel que recebe o retorno de `render`

> Import√¢ncia: baixa

```javascript
// ‚ùå
const wrapper = render(<Example prop="1" />)
wrapper.rerender(<Example prop="2" />)

// ‚úÖ
const {rerender} = render(<Example prop="1" />)
rerender(<Example prop="2" />)
```

O nome `wrapper` √© coisa antiga herdada do `enzyme` e n√≥s n√£o precisamos disso aqui. O valor retornado de `render` n√£o est√° "wrapping" nada. √â simplesmente uma cole√ß√£o de utilidades que (gra√ßas ao pr√≥ximo item) voc√™ realmente n√£o deveria precisar (com frequ√™ncia) de qualquer forma.

**Conselho: desestruture o que voc√™ precisar do retorno do `render` ou chame de `view`.**

<br />

## Usar `cleanup`

> Import√¢ncia: m√©dia

```javascript
// ‚ùå
import {render, screen, cleanup} from '@testing-library/react'

afterEach(cleanup)

// ‚úÖ
import {render, screen} from '@testing-library/react'
```

J√° faz bastante tempo que `cleanup` acontece automaticamente (com suporte na maioria dos grandes frameworks de teste) e voc√™ n√£o precisa se preocupar com isso ([saiba mais](https://testing-library.com/docs/react-testing-library/api#cleanup)).

**Conselho: n√£o use `cleanup`**

<br />

## N√£o usar screen

> Import√¢ncia: m√©dia

```javascript
// ‚ùå
const {getByRole} = render(<Example />)
const errorMessageNode = getByRole('alert')

// ‚úÖ
render(<Example />)
const errorMessageNode = screen.getByRole('alert')
```

`screen` [foi adicionado na vers√£o v6.11.0 da DOM Testing Library](https://github.com/testing-library/dom-testing-library/releases/tag/v6.11.0) (o que significa que voc√™ deveria ter acesso a ela em qualquer ambiente com `@testing-library/react@>=9`). Ela vem do mesmo import que voc√™ recebe `render`:

```javascript
import {render, screen} from '@testing-library/react'
```

O benef√≠cio de utilizar `screen` √© que voc√™ n√£o precisa ficar mudando o que voc√™ recebe do `render` conforme queira adicionar/remover as queries que voc√™ precisa. Voc√™ s√≥ precisa digitar `screen.` e deixar a m√°gica do autocomplete do seu editor cuidar do resto.

A √∫nica exce√ß√£o para isso √© se voc√™ est√° usando o `container` ou `baseElement` que voc√™ provavelmente deveria evitar (eu honestamente n√£o consigo mais pensar em um caso de uso leg√≠timo para essas op√ß√µes e elas s√≥ existem por raz√µes hist√≥ricas neste momento)

Voc√™ tamb√©m pode usar [`screen.debug`](https://testing-library.com/docs/dom-testing-library/api-queries#screendebug) ao inv√©s de `debug`

**Conselho: use `screen` para fazer as queries e usar o debug.**

<br />

## Usar a asser√ß√£o (assertion) errada

> Import√¢ncia: alta

```javascript
const button = screen.getByRole('button', {name: /disabled button/i})

// ‚ùå
expect(button.disabled).toBe(true)
// Mensagem de erro:
//  expect(received).toBe(expected) // Object.is equality
//
//  Expected: true
//  Received: false

// ‚úÖ
expect(button).toBeDisabled()
// Mensagem de erro:
//   Received element is not disabled:
//     <button />
```

Aquela asser√ß√£o `toBeDisabled` vem da [`jest-dom`](https://github.com/testing-library/jest-dom). √â fortemente recomendado o uso da `jest-dom` pois as mensagens de erro s√£o muito melhores.

**Conselho: instale e use [`@testing-library/jest-dom`](https://github.com/testing-library/jest-dom#tobedisabled)**

<br />

## Colocar `act` em volta das coisas desnecessariamente

> Import√¢ncia: m√©dia

```javascript
// ‚ùå
act(() => {
  render(<Example />)
})

const input = screen.getByRole('textbox', {name: /choose a fruit/i})
act(() => {
  fireEvent.keyDown(input, {key: 'ArrowDown'})
})

// ‚úÖ
render(<Example />)
const input = screen.getByRole('textbox', {name: /choose a fruit/i})
fireEvent.keyDown(input, {key: 'ArrowDown'})
```

Eu vejo pessoas colocando `act` em volta de coisas como essas porque elas veem esses warnings com `act` o tempo todo e est√£o apenas tentando desesperadamente fazer com que eles desapare√ßam, mas o que elas n√£o sabem √© que `render` e `fireEvent` j√° est√£o envolvidos por `act`! Ent√£o aqueles ali que elas colocam em volta n√£o est√° fazendo nada √∫til.

Na maioria das vezes, se voc√™ est√° vendo um warning com `act`, n√£o √© algo pra s√≥ ignorar ou tentar fazer desaparecer, na verdade isso est√° te avisando que algo inesperado est√° acontecendo com seu teste. Voc√™ pode aprender mais sobre isso com o meu blog post (e v√≠deos): [Corrija o warning "not wrapped in act(...)"](https://kentcdodds.com/blog/fix-the-not-wrapped-in-act-warning).

**Conselho: Aprenda quando `act` √© necess√°rio e n√£o coloque `act` em volta das coisas desnecessariamente.**

<br />

## Usar a query errada

> Import√¢ncia: alta

```javascript
// ‚ùå
// Assumindo que voc√™ est√° trabalhando em cima desse DOM:
// <label>Username</label><input data-testid="username" />
screen.getByTestId('username')

// ‚úÖ
// Mude o DOM para ser acess√≠vel associando a label ao input e informando o tipo do input
// <label for="username">Username</label><input id="username" type="text" />
screen.getByRole('textbox', {name: /username/i})
```

N√≥s mantemos uma p√°gina chamada ["Which query should I use?" (Qual query eu deveria usar?)](https://testing-library.com/docs/guide-which-query) de queries que voc√™ deveria tentar usar na ordem que voc√™ deveria tentar usar. Se o seu objetivo est√° alinhado com o nosso que √© ter testes que tragam confian√ßa que sua aplica√ß√£o vai funcionar quando seus usu√°rios a usarem, ent√£o voc√™ vai querer aplicar as queries no DOM o mais pr√≥ximo poss√≠vel da forma que o seu usu√°rio final faz (indiretamente, mas faz). As queries que n√≥s fornecemos te ajudam a fazer isso, mas nem todas as queries s√£o criadas igualmente.

### Usar `container` para fazer query por elementos

Como uma subse√ß√£o de "Usar a query errada" Eu quero falar sobre usando a query diretamente no `container`.

```javascript
// ‚ùå
const {container} = render(<Example />)
const button = container.querySelector('.btn-primary')
expect(button).toHaveTextContent(/click me/i)

// ‚úÖ
render(<Example />)
screen.getByRole('button', {name: /click me/i})
```

N√≥s queremos garantir que seus usu√°rios possam interagir com a sua UI e se voc√™ fizer as queries por a√≠ usando `querySelector` n√≥s perdemos grande parte dessa confian√ßa, o teste √© mais dif√≠cil de ler, e vai quebrar com mais frequ√™ncia. Isso est√° de m√£os dadas com a pr√≥xima subse√ß√£o:

### N√£o fazer a query por texto

Como uma subse√ß√£o de "Usar a query errada", eu quero falar porque eu recomendo que voc√™ use a query pelo texto _verdadeiro_  (Em caso de localiza√ß√£o, eu recomendo que use o padr√£o), ao inv√©s ficar usando test IDs ou outros mecanismos em todo canto.

```javascript
// ‚ùå
screen.getByTestId('submit-button')

// ‚úÖ
screen.getByRole('button', {name: /submit/i})
```

Se voc√™ n√£o usa a query com o texto verdadeiro, ent√£o voc√™ tem que fazer trabalho extra para ter certeza
que suas tradu√ß√µes est√£o sendo aplicadas corretamente. A maior reclama√ß√£o
que eu escuto sobre isso √© que faz com que criadores de conte√∫do quebrem seus testes. Minha
r√©plica a isso √© que primeiro, se um criador de conte√∫do troca "Username" por "Email",
essa √© uma troca que eu definitivamente quero saber sobre (porque eu vou ter que mudar minha implementa√ß√£o).
Al√©m disso, se h√° uma situa√ß√£o que eles quebram algo, arrumar isso n√£o toma tanto tempo assim.
√â f√°cil de identificar e de corrigir.

Ent√£o o custo √© bem baixo, e o benef√≠cio √© que voc√™ aumenta a confian√ßa de que suas tradu√ß√µes est√£o sendo aplicadas corretamente _e_ seus testes s√£o mais f√°ceis de escrever e de ler.

Vale mencionar que nem todo mundo concorda comigo nisso, fica a vontade para ler
mais sobre isso [nesse fio no twitter](https://twitter.com/kentcdodds/status/1203179007644012544).

### N√£o usar `*ByRole` na maior parte do tempo

Como uma subse√ß√£o de "Usar a query errada" eu quero falar sobre `*ByRole`.
Nas vers√µes recentes, as queries `*ByRole` foram seriamente melhoradas
(primeiramente gra√ßas ao grande trabalho do [Sebastian Silbermann](https://twitter.com/sebsilbermann))
e agora s√£o as mais recomendadas para o uso nos testes dos seus componentes. Aqui est√£o algumas das minhas features favoritas desse tipo de query.

A op√ß√£o `name` permite que voc√™ fa√ßa a query por elementos pelo seu 
["Nome acess√≠vel"](https://www.w3.org/TR/accname-1.1/) que √© o que leitores de tela
ir√£o ler ao ler o elemento _e_ funciona mesmo que seu elemento tenha o
texto dividido entre m√∫ltiplos elementos. Por exemplo:

```javascript
// Assumindo que n√≥s temos essa estrutura de DOM para trabalhar
// <button><span>Hello</span> <span>World</span></button>

screen.getByText(/hello world/i)
// ‚ùå Falha com o seguinte erro:
// Unable to find an element with the text: /hello world/i. This could be
// because the text is broken up by multiple elements. In this case, you can
// provide a function for your text matcher to make your matcher more flexible.

screen.getByRole('button', {name: /hello world/i})
// ‚úÖ funciona!
```

Uma raz√£o pela qual as pessoas n√£o usam as queries `*ByRole` √© porque elas n√£o est√£o familiarizadas
com os _roles_ impl√≠citos colocado nos elementos.
[Aqui est√° uma lista de Roles no MDN](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles).
Outra que tamb√©m √© uma das minhas features favoritas das queries `*ByRole` √© que se n√£o conseguirmos
encontrar um elemento com o role que voc√™ espec√≠ficou, n√≥s vamos mostrar na tela n√£o somente o DOM inteiro como
em caso de erros quando usadas as variantes de `get*` ou `find*`, mas tamb√©m iremos mostrar todos os roles dispon√≠veis para voc√™ poder usar na query.

```javascript
// Assumindo que esse √© o DOM que n√≥s temos para trabalhar
// <button><span>Hello</span> <span>World</span></button>
screen.getByRole('blah')
```

Isso vai falhar com a seguinte mensagem de erro:

```javascript
TestingLibraryElementError: Unable to find an accessible element with the role "blah"

Here are the accessible roles:

  button:

  Name "Hello World":
  <button />

  --------------------------------------------------

<body>
  <div>
    <button>
      <span>
        Hello
      </span>

      <span>
        World
      </span>
    </button>
  </div>
</body>
```

Note que n√≥s n√£o tivemos que adicionar `role=button` ao nosso bot√£o para que ele tivesse o role button.
Esse √© um role impl√≠cito, o que nos leva perfeitamente ao nosso pr√≥ximo item... 

**Conselho: Leia e siga as recomenda√ß√µes do [Guia "Qual Query Eu Deveria Usar?"](https://testing-library.com/docs/guide-which-query).**

<br />

## Adicionar `aria-`, `role`, e outros atributos de acessibilidade incorretamente

> Import√¢ncia: alta

```javascript
// ‚ùå
render(<button role="button">Click me</button>)

// ‚úÖ
render(<button>Click me</button>)
```

Sair distribuindo atributos de acessibilidade sem pensar n√£o s√≥ √© desnecess√°rio (como no
caso acima), mas tamb√©m pode confundir os leitores de tela e seus usu√°rios. Os atributos
de acessibilidade deveriam ser utilizados apenas quando o HTML sem√¢ntico n√£o √© o bastante (como no caso de voc√™ estar desenvolvendo uma UI n√£o-nativa que voc√™ quer
tornar acess√≠vel [como um autocomplete](https://github.com/downshift-js/downshift)). Se √©
isso que voc√™ est√° desenvolvendo, use uma biblioteca existente que seja acess√≠vel ou siga as pr√°ticas indicadas para WAI-ARIA.
Geralmente eles tem [√≥timos exemplos](https://www.w3.org/TR/wai-aria-practices/examples/accordion/accordion.html).

> Obs: para fazer `input`s acess√≠veis via "role" voc√™ ter√° que especificar o
> atributo `type`!

**Conselho: Evite adicionar atributos de acessibilidade desnecess√°rios ou incorretos.**

<br />

## N√£o usar `@testing-library/user-event`

> Import√¢ncia: m√©dia

```javascript
// ‚ùå
fireEvent.change(input, {target: {value: 'hello world'}})

// ‚úÖ
userEvent.type(input, 'hello world')
```

[`@testing-library/user-event`](https://github.com/testing-library/user-event)
√© um pacote desenvolvido baseado no `fireEvent`, mas ele fornece v√°rios m√©todos 
que se assemelham mais com as intera√ß√µes feitas pelo usu√°rio. No exemplo acima, 
`fireEvent.change` vai simplesmente disparar um √∫nico evento change no input.
Entretanto, o `userEvent.type`, al√©m do change, vai disparar os eventos `keyDown`, `keyPress` e `keyUp`
para cada um dos caracteres. √â muito mais pr√≥ximo da intera√ß√£o real do usu√°rio.
Isso tem o benef√≠cio de funcionar bem com bibliotecas que talvez voc√™ use que n√£o
reagem ao evento change e sim aos outros.

N√≥s ainda estamos trabalhando na `@testing-library/user-event` para garantir que entregue
o que n√≥s prometemos: disparar todos os mesmo eventos que o usu√°rio dispararia ao fazer uma a√ß√£o espec√≠fica.
Eu n√£o acho que j√° chegamos l√° e √© por isso que ela n√£o vem
por padr√£o com o `@testing-library/dom` (mas pode ser que venha em algum momento no futuro).
Apesar disso, eu estou confiante o bastante para recomendar que voc√™ d√™ uma olhada e use as utilidades que ela fornece ao inv√©s de `fireEvent`.

**Conselho: Use `@testing-library/user-event` ao inv√©s de `fireEvent` onde for poss√≠vel.**

<br />

## Usar as variantes `query*` para qualquer coisa diferente de testar que coisas n√£o existem

> Import√¢ncia: alta

```javascript
// ‚ùå
expect(screen.queryByRole('alert')).toBeInTheDocument()

// ‚úÖ
expect(screen.getByRole('alert')).toBeInTheDocument()
expect(screen.queryByRole('alert')).not.toBeInTheDocument()
```

A _√∫nica_ raz√£o que as queries do tipo `query*` s√£o fornecidas √© para voc√™
ter uma fun√ß√£o que pode chamar sem estourar um erro se nenhum elemento √© encontrado
(elas retornam `null` quando isso acontece). A _√∫nica_ raz√£o para qual isso √© √∫til √©
para verificar que um elemento n√£o foi renderizado na p√°gina.

**Conselho: Use as variantes `query*` somente quando seu teste quer garantir que um elemento n√£o pode ser encontrado.**

<br />

## Usar `waitFor` para esperar por elementos que podem ser encontrados usando a query `find*`

> Import√¢ncia: alta

```javascript
// ‚ùå
const submitButton = await waitFor(() =>
  screen.getByRole('button', {name: /submit/i}),
)

// ‚úÖ
const submitButton = await screen.findByRole('button', {name: /submit/i})
```

Esses dois trechos de c√≥digo s√£o basicamente equivalentes (as queries `find*` usam `waitFor` por debaixo dos panos),
mas a segunda √© mais simples e tem uma mensagem de erro melhor.

**Conselho: use `find*` sempre que voc√™ queira fazer uma query por algo que pode n√£o estar dispon√≠vel naquele momento.**

<br />

## Passar uma fun√ß√£o de callback vazia para `waitFor`

> Import√¢ncia: alta

```javascript
// ‚ùå
await waitFor(() => {})
expect(window.fetch).toHaveBeenCalledWith('foo')
expect(window.fetch).toHaveBeenCalledTimes(1)

// ‚úÖ
await waitFor(() => expect(window.fetch).toHaveBeenCalledWith('foo'))
expect(window.fetch).toHaveBeenCalledTimes(1)
```

O prop√≥sito de `waitFor` √© permitir voc√™ esperar que algo espec√≠fico aconte√ßa.
Se voc√™ passar uma fun√ß√£o de callback vazia pode ser que funcione hoje porque tudo que voc√™ precisa esperar
√© por "um tick do event loop" gra√ßas a forma que seus mocks funcionam. Mas voc√™ vai ficar com um teste fr√°gil
que pode facilmente falhar caso voc√™ refatore a l√≥gica do trecho ass√≠ncrono do seu c√≥digo.

**Conselho: Espere por uma asser√ß√£o espec√≠fica dentro do `waitFor`.**

<br />

## Ter m√∫ltiplas asser√ß√µes dentro de um √∫nico callback passado para o `waitFor`

> Import√¢ncia: baixa

```javascript
// ‚ùå
await waitFor(() => {
  expect(window.fetch).toHaveBeenCalledWith('foo')
  expect(window.fetch).toHaveBeenCalledTimes(1)
})

// ‚úÖ
await waitFor(() => expect(window.fetch).toHaveBeenCalledWith('foo'))
expect(window.fetch).toHaveBeenCalledTimes(1)
```

Digamos que no exemplo acima, `window.fetch` foi chamado duas vezes. Ent√£o, o `waitFor` vai falhar,
entretanto, n√≥s vamos ter que esperar pelo timeout antes que vejamos a falha do teste.
Colocando apenas uma asser√ß√£o ali, n√≥s podemos esperar ambos, que a UI chege ao estado sob o qual n√≥s queremos fazer os testes,
e tamb√©m falhe mais r√°pido se alguma das asser√ß√µes acabar falhando.

**Conselho: coloque apenas uma asser√ß√£o dentro do callback.**

<br />

## Causar efeitos colaterais (side-effects) dentro de `waitFor`

> Import√¢ncia: alta

```javascript
// ‚ùå
await waitFor(() => {
  fireEvent.keyDown(input, {key: 'ArrowDown'})
  expect(screen.getAllByRole('listitem')).toHaveLength(3)
})

// ‚úÖ
fireEvent.keyDown(input, {key: 'ArrowDown'})
await waitFor(() => {
  expect(screen.getAllByRole('listitem')).toHaveLength(3)
})
```

`waitFor` √© indicado para coisas que v√£o levar uma quantidade de tempo indeterminada
entre a a√ß√£o que voc√™ executou e a asser√ß√£o que voc√™ est√° esperando se tornar verdade. Por conta disso,
o callback pode ser chamado (ou testado) um n√∫mero indeterminado de vezes numa frequ√™ncia tamb√©m indeterminada
(j√° que √© chamado repetidas vezes com um intervalo e tamb√©m sempre que o DOM sofre muta√ß√µes). Ent√£o, isso significa que
o seu efeito colateral pode estar sendo executado v√°rias vezes!

Isso tamb√©m significa que voc√™ n√£o pode usar snapshots com `waitFor`. Se voc√™ quer usar o teste por snapshot, ent√£o primeiro use o `waitFor`
para esperar por uma asser√ß√£o espec√≠fica, e depois voc√™ pode testar usando o snapshot.

**Conselho: coloque efeitos colaterais (side-effects) fora da fun√ß√£o de callback passada para o `waitFor` e reserve a fun√ß√£o de callback apenas para a asser√ß√£o.**

<br />

## Usar as variantes de `get*` como asser√ß√µes

> Import√¢ncia: baixa

```javascript
// ‚ùå
screen.getByRole('alert', {name: /error/i})

// ‚úÖ
expect(screen.getByRole('alert', {name: /error/i})).toBeInTheDocument()
```

Esse n√£o √© grande coisa na verdade, mas eu pensei em mencion√°-lo e dar minha opini√£o.
Se as queries `get*` n√£o tiverem sucesso em encontrar o elemento,
elas v√£o disparar uma mensagem de error bem √∫til que mostra a estrutura completa do DOM
(com syntax highlighting) que vai te ajudar a debugar.
Por conta disso, √© imposs√≠vel que a asser√ß√£o falhe (porque a query vai disparar o erro antes que a asser√ß√£o tenha chance de falhar).

Por essa raz√£o, muitas pessoas deixam sem a asser√ß√£o. Honestamente, isso √© ok,
mas eu, pessoalmente, mantenho a asser√ß√£o l√° s√≥ para comunicar para os
leitores do c√≥digo que n√£o √© apenas uma query perdida depois de alguma refatora√ß√£o
e sim que eu estou explicitamente testando que aquilo existe.


**Conselho: Se voc√™ quer testar se algo existe, fa√ßa a asser√ß√£o explicitamente.**

<br />

## Conclus√£o


Como mantenedores da fam√≠lia de ferramentas Testing Library, damos o nosso melhor para fazer
APIs que levam as pessoas a usarem as coisas da forma mais eficaz poss√≠vel e onde isso
falha, tentamos documentar corretamente. Mas isso pode ser bem
dif√≠cil (especialmente conforme as APIs s√£o alteradas/melhoradas/etc). Espero que isso tenha sido √∫til para
voc√™s. N√≥s realmente s√≥ queremos que voc√™s tenham mais sucesso na entrega do seu software
com confian√ßa.

Boa Sorte!
