---
slug: 'erros-comuns-com-react-testing-library'
title: 'Erros comuns com React Testing Library [Tradu√ß√£o]'
date: '2021-04-24'
author: 'Kent C. Dodds'
description:
  '_Alguns erros que eu vejo frequentemente ao utilizarem a React Testing Library._ Imagem de [Sarah Kilian](https://unsplash.com/photos/52jRtc2S_VE)'
tags:
 - react
 - tradu√ß√£o
keywords:
  - 'react'
  - 'testing'
  - 'react testing library'
  - 'dom testing library'
  - 'async'
banner: './images/banner.jpg'
---

[Artigo original em Ingl√™s](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library)

Ol√° üëã Eu criei a biblioteca React Testing porque eu n√£o estava satisfeito com o cen√°rio de testes naquele momento. Ela se expandiu para a DOM Testing Library e agora n√≥s temos implementa√ß√µes da Testing Library (wrappers) para todos frameworks JavaScript populares e ferramenta de teste que focam no DOM (e at√© algumas que n√£o).


Com o passar do tempo, n√≥s fizemos algumas pequenas mudan√ßas na API e n√≥s descobrimos alguns padr√µes sub√≥timos. Apesar dos nossos esfor√ßos para documentar a "melhor forma" de usar as ferramentas que n√≥s fornecemos, eu ainda vejo blog posts e testes escritos seguindo esses padr√µes sub√≥timos e eu gostaria de passar por cada um deles, comentar o porqu√™ de n√£o serem √≥timos e como voc√™ pode melhorar seus testes para evitar essas armadilhas.

> Nota: Eu clasifiquei cada um desses pela import√¢ncia:
>
> - baixa: isso √© majoritariamente opini√£o minha, sinta-se a vontade para ignorar e voc√™ provavelmente n√£o vai ter problemas
> - m√©dia: talvez voc√™ encontre alguns bugs, perca confian√ßa, ou tenha trabalho extra desnecessariamente
> - alta: escute esse conselho! Voc√™ provavelmente est√° perdendo confian√ßa ou ter√° testes problem√°ticos

<br/>

## N√£o usar os plugins para ESLint da Testing Library

> Import√¢ncia: m√©dia

Se voc√™ quer evitar v√°rios desses erros comuns, ent√£o os plugins oficiais para ESLint podem te ajudar bastante:

- [eslint-plugin-testing-library](https://github.com/testing-library/eslint-plugin-testing-library)
- [eslint-plugin-jest-dom](https://github.com/testing-library/eslint-plugin-jest-dom)

**Conselho: Instale e use os plugins para ESLint data Testing Library**

<br />

## Usar `wrapper` como nome para a vari√°vel que recebe o retorno de `render`

> Import√¢ncia: baixa

```javascript
// ‚ùå
const wrapper = render(<Example prop="1" />)
wrapper.rerender(<Example prop="2" />)

// ‚úÖ
const {rerender} = render(<Example prop="1" />)
rerender(<Example prop="2" />)
```

O nome `wrapper` √© velharia herdada do `enzyme` e n√≥s n√£o precisamos disso aqui. O valor retornado de `render` n√£o est√° "wrapping" nada. √â simplesmente uma cole√ß√£o de utilidades que (gra√ßas ao pr√≥ximo item) voc√™ realmente n√£o deveria precisar com frequ√™ncia de qualquer forma.

**Conselho: desestruture o que voc√™ precisar do retorno do `render` ou chame de `view`.**

<br />

## Usar `cleanup`

> Import√¢ncia: m√©dia

```javascript
// ‚ùå
import {render, screen, cleanup} from '@testing-library/react'

afterEach(cleanup)

// ‚úÖ
import {render, screen} from '@testing-library/react'
```

J√° faz bastante tempo que `cleanup` acontece automaticamente (com suporte na maioria dos grandes frameworks de teste) e voc√™ n√£o precisa se preocupar com isso.
[Saiba mais](https://testing-library.com/docs/react-testing-library/api#cleanup).

**Conselho: n√£o use `cleanup`**

<br />

## N√£o usar screen

> Import√¢ncia: m√©dia

```javascript
// ‚ùå
const {getByRole} = render(<Example />)
const errorMessageNode = getByRole('alert')

// ‚úÖ
render(<Example />)
const errorMessageNode = screen.getByRole('alert')
```

`screen` [foi adicionado na vers√£o v6.11.0 da DOM Testing Library](https://github.com/testing-library/dom-testing-library/releases/tag/v6.11.0) (o que significa que voc√™ deveria ter acesso a ela em qualquer ambiente com `@testing-library/react@>=9`). Ela vem do mesmo import que voc√™ recebe `render`:

```javascript
import {render, screen} from '@testing-library/react'
```

O benef√≠cio de utilizar `screen` √© que voc√™ n√£o precisa ficar mudando o que voc√™ recebe do `render` conforme queira adicionar/remover as queries que voc√™ precisa. Voc√™ s√≥ precisa digitar `screen.` e deixar a m√°gica do autocomplete do seu editor cuidar do resto.

A √∫nica exce√ß√£o para isso √© se voc√™ est√° usando o `container` ou `baseElement` que voc√™ provavelmente deveria evitar (eu honestamente n√£o consigo mais pensar em um caso de uso leg√≠timo para essas op√ß√µes e elas s√≥ existem por raz√µes hist√≥ricas neste momento)

Voc√™ tamb√©m pode usar [`screen.debug`](https://testing-library.com/docs/dom-testing-library/api-queries#screendebug) ao inv√©s de `debug`

**Conselho: use `screen` para fazer as queries e usar o debug.**

<br />

## Usar a asser√ß√£o (assertion) errada

> Import√¢ncia: alta

```javascript
const button = screen.getByRole('button', {name: /disabled button/i})

// ‚ùå
expect(button.disabled).toBe(true)
// Mensagem de erro:
//  expect(received).toBe(expected) // Object.is equality
//
//  Expected: true
//  Received: false

// ‚úÖ
expect(button).toBeDisabled()
// Mensagem de erro:
//   Received element is not disabled:
//     <button />
```

Aquela asser√ß√£o `toBeDisabled` vem da [`jest-dom`](https://github.com/testing-library/jest-dom). √â fortemente recomendado o uso da `jest-dom` pois as mensagens de erro s√£o muito melhores.

**Conselho: instale e use

<br />
[`@testing-library/jest-dom`](https://github.com/testing-library/jest-dom#tobedisabled)**

## Colocar `act` em volta das coisas desnecessariamente

> Import√¢ncia: m√©dia

```javascript
// ‚ùå
act(() => {
  render(<Example />)
})

const input = screen.getByRole('textbox', {name: /choose a fruit/i})
act(() => {
  fireEvent.keyDown(input, {key: 'ArrowDown'})
})

// ‚úÖ
render(<Example />)
const input = screen.getByRole('textbox', {name: /choose a fruit/i})
fireEvent.keyDown(input, {key: 'ArrowDown'})
```

Eu vejo pessoas colocando `act` em volta de coisas como essas porque elas veem esses warnings com `act` o tempo todo e est√£o apenas tentando desesperadamente fazer com que eles desapare√ßam, mas o que eles n√£o sabem √© que `render` e `fireEvent` j√° est√£o envolvidos por `act`! Ent√£o aqueles ali que elas colocam em volta n√£o est√° fazendo nada √∫til.

Na maioria das vezes, se voc√™ est√° vendo um warning com `act`, n√£o √© algo pra s√≥ ignorar ou tentar fazer desaparecer, na verdade isso est√° te avisando que algo inesperado est√° acontecendo com seu teste. Voc√™ pode aprender mais sobre isso com o meu blog post (e v√≠deos): [Corrija o warning "not wrapped in act(...)"](https://kentcdodds.com/blog/fix-the-not-wrapped-in-act-warning).

**Conselho: Aprenda quando `act` √© necess√°rio e n√£o coloque `act` em volta das coisas desnecessariamente.**

<br />

## Usar a query errada

> Import√¢ncia: alta

```javascript
// ‚ùå
// Assumindo que voc√™ est√° trabalhando em cima desse DOM:
// <label>Username</label><input data-testid="username" />
screen.getByTestId('username')

// ‚úÖ
// Mude o DOM para ser acess√≠vel associando a label ao input e informando o tipo do input
// <label for="username">Username</label><input id="username" type="text" />
screen.getByRole('textbox', {name: /username/i})
```

N√≥s mantemos uma p√°gina chamada ["Which query should I use?" (Qual query eu deveria usar?)](https://testing-library.com/docs/guide-which-query) de queries que voc√™ deveria tentar usar na ordem que voc√™ deveria tentar usar. Se o seu objetivo est√° alinhado com o nosso que √© ter testes que tragam confian√ßa que sua aplica√ß√£o ir√° funcionar quando seus usu√°rios a usarem, ent√£o voc√™ vai querer aplicar as queries no DOM o mais pr√≥ximo poss√≠vel da forma que o seu usu√°rio final faz. As queries que n√≥s fornecemos te ajudam a fazer isso, mas nem todas as queries s√£o criadas igualmente.

### Usar `container` para fazer query por elementos

Como uma subse√ß√£o de "Usar a query errada" Eu quero falar sobre usando a query diretamente no `container`.

```javascript
// ‚ùå
const {container} = render(<Example />)
const button = container.querySelector('.btn-primary')
expect(button).toHaveTextContent(/click me/i)

// ‚úÖ
render(<Example />)
screen.getByRole('button', {name: /click me/i})
```

N√≥s queremos garantir que seus usu√°rios possam interagir com a sua UI e se voc√™ fazer as queries por a√≠ usando `querySelector` n√≥s perdemos grande parte dessa confian√ßa, o teste √© mais dif√≠cil de ler, e vai quebrar com mais frequ√™ncia. Isso est√° de m√£os dadas com a pr√≥xima subse√ß√£o:

### N√£o fazer a query por texto

Como uma subse√ß√£o de "Usar a query errada", eu quero falar porque eu recomendo que voc√™ use a query pelo texto _verdadeiro_  (Em caso de localiza√ß√£o, eu recomendo que use o padr√£o), ao inv√©s ficar usando test IDs ou outros mecanismos em todo canto.

```javascript
// ‚ùå
screen.getByTestId('submit-button')

// ‚úÖ
screen.getByRole('button', {name: /submit/i})
```

Se voc√™ n√£o usa a query com o texto verdadeiro, ent√£o voc√™ tem que fazer trabalho extra para ter certeza
que suas tradu√ß√µes est√£o sendo aplicadas corretamente. A maior reclama√ß√£o
que eu escuto sobre isso √© que isso faz com que criadores de conte√∫do quebrem seus testes. Minha
r√©plica a isso √© que primeiro, se um criador de conte√∫do troca "Username" por "Email",
essa √© uma troca que eu definitivamente quero saber sobre (porque eu vou ter que mudar minha implementa√ß√£o).
Al√©m disso, se h√° uma situa√ß√£o que eles quebram algo, arrumar isso n√£o toma tanto tempo assim.
√â f√°cil de identificar e de corrigir.

Ent√£o o custo √© bem baixo, e o benef√≠cio √© que voc√™ aumenta a confian√ßa de que suas tradu√ß√£o est√£o sendo aplicadas corretamente _e_ seus testes s√£o mais f√°ceis de escrever e de ler.

Vale mencionar que nem todo mundo concorda comigo nisso, fica a vontade para ler
mais sobre isso [nesse fio no twitter](https://twitter.com/kentcdodds/status/1203179007644012544).

### N√£o usar `*ByRole` na maior parte do tempo

Como uma subse√ß√£o de "Usar a query errada" eu quero falar sobre `*ByRole`.
Nas vers√µes recentes, as queries `*ByRole` foram seriamente melhoradas
(primeiramente gra√ßas ao grande trabalho do [Sebastian Silbermann](https://twitter.com/sebsilbermann))
e agora s√£o as mais recomendadas para o uso nos testes dos seus componentes. Aqui est√£o algumas das minhas features favoritas desse tipo de query.

A op√ß√£o `name` permite que voc√™ fa√ßa a query por elementos pelo seu 
["Nome acess√≠vel"](https://www.w3.org/TR/accname-1.1/) que √© o que leitores de tela
ir√£o ler ao ler o elemento _e_ funciona mesmo que seu elemento tenha o
texto dividido entre m√∫ltiplos elementos. Por exemplo:

```javascript
// Assumindo que n√≥s temos essa estrutura de DOM para trabalhar
// <button><span>Hello</span> <span>World</span></button>

screen.getByText(/hello world/i)
// ‚ùå Falha com o seguinte erro:
// Unable to find an element with the text: /hello world/i. This could be
// because the text is broken up by multiple elements. In this case, you can
// provide a function for your text matcher to make your matcher more flexible.

screen.getByRole('button', {name: /hello world/i})
// ‚úÖ works!
```

Uma raz√£o pela qual as pessoas n√£o usam as queries `*ByRole` √© porque elas n√£o est√£o familiarizadas
com os _roles_ impl√≠citos colocado nos elementos.
[Aqui est√° uma lista de Roles no MDN](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles).
Outra que tamb√©m √© uma das minhas features favoritas das queries `*ByRole` √© que se n√£o conseguirmos
encontrar um elemento com o role que voc√™ espec√≠ficou, n√≥s vamos mostrar na tela n√£o somente o DOM inteiro como
em caso de erros quando usado as variantes de `get*` ou `find*`, mas tamb√©m iremos mostrar todos os roles dispon√≠veis para voc√™ poder usar na query.

```javascript
// Assumindo que esse √© o DOM que n√≥s temos para trabalhar
// <button><span>Hello</span> <span>World</span></button>
screen.getByRole('blah')
```

Isso vai falhar com a seguinte mensagem de erro:

```javascript
TestingLibraryElementError: Unable to find an accessible element with the role "blah"

Here are the accessible roles:

  button:

  Name "Hello World":
  <button />

  --------------------------------------------------

<body>
  <div>
    <button>
      <span>
        Hello
      </span>

      <span>
        World
      </span>
    </button>
  </div>
</body>
```

Note que n√≥s n√£o tivemos que adicionar `role=button` ao nosso bot√£o para que ele tivesse o role button.
Esse √© um role impl√≠cito, o que nos leva perfeitamente ao nosso pr√≥ximo... 

**Conselho: Leia e siga as recomenda√ß√µes do [Guia "Qual Query Eu Deveria Usar?"](https://testing-library.com/docs/guide-which-query).**

<br />

## Adicionar `aria-`, `role`, e outros atributos de acessibilidade incorretamente

> Import√¢ncia: alta

```javascript
// ‚ùå
render(<button role="button">Click me</button>)

// ‚úÖ
render(<button>Click me</button>)
```

Sair distribuindo atributos de acessibilidade sem pensar n√£o √© s√≥ desnecess√°rio (como no
caso acima), mas tamb√©m pode confundir os leitores de tela e seus usu√°rios. Os atributos
de acessibilidade deveriam ser utilizadas apenas quando o HTML sem√¢ntico n√£o √© o bastante
no seu caso de uso (como o caso de voc√™ estar desenvolvendo uma UI n√£o-nativa que voc√™ quer
tornar acess√≠vel [como um autocomplete](https://github.com/downshift-js/downshift)). Se √©
isso que voc√™ est√° desenvolvendo, use uma biblioteca existente que seja acess√≠vel ou siga as pr√°ticas indicadas para WAI-ARIA.
Geralmente eles tem [√≥timos exemplos](https://www.w3.org/TR/wai-aria-practices/examples/accordion/accordion.html).

> Obs: para fazer `input`s acess√≠veis via "role" voc√™ ter√° que especificar o
> atributo `type`!

**Conselho: Evite adicionar atributos de acessibilidade desnecess√°rios ou incorretos.**

<br />

## Not using `@testing-library/user-event`

> Import√¢ncia: m√©dia

```javascript
// ‚ùå
fireEvent.change(input, {target: {value: 'hello world'}})

// ‚úÖ
userEvent.type(input, 'hello world')
```

[`@testing-library/user-event`](https://github.com/testing-library/user-event)
is a package that's built on top of `fireEvent`, but it provides several methods
that resemble the user interactions more closely. In the example above,
`fireEvent.change` will simply trigger a single change event on the input.
However the `type` call, will trigger `keyDown`, `keyPress`, and `keyUp` events
for each character as well. It's much closer to the user's actual interactions.
This has the benefit of working well with libraries that you may use which don't
actually listen for the change event.

We're still working on `@testing-library/user-event` to ensure that it delivers
what it promises: firing all the same events the user would fire when performing
a specific action. I don't think we're quite there yet and this is why it's not
baked-into `@testing-library/dom` (though it may be at some point in the
future). However, I'm confident enough in it to recommend you give it a look and
use it's utilities over `fireEvent`.

**Conselho: Use `@testing-library/user-event` over `fireEvent` where possible.**

<br />

## Using `query*` variants for _anything_ except checking for non-existence

> Import√¢ncia: alta

```javascript
// ‚ùå
expect(screen.queryByRole('alert')).toBeInTheDocument()

// ‚úÖ
expect(screen.getByRole('alert')).toBeInTheDocument()
expect(screen.queryByRole('alert')).not.toBeInTheDocument()
```

The _only_ reason the `query*` variant of the queries is exposed is for you to
have a function you can call which does not throw an error if no element is
found to match the query (it returns `null` if no element is found). The _only_
reason this is useful is to verify that an element is not rendered to the page.

**Conselho: Only use the `query*` variants for asserting that an element cannot be

<br />
found.**

## Using `waitFor` to wait for elements that can be queried with `find*`

> Import√¢ncia: alta

```javascript
// ‚ùå
const submitButton = await waitFor(() =>
  screen.getByRole('button', {name: /submit/i}),
)

// ‚úÖ
const submitButton = await screen.findByRole('button', {name: /submit/i})
```

Those two bits of code are basically equivalent (`find*` queries use `waitFor`
under the hood), but the second is simpler and the error message you get will be
better.

**Conselho: use `find*` any time you want to query for something that may not be

<br />
available right away.**

## Passing an empty callback to `waitFor`

> Import√¢ncia: alta

```javascript
// ‚ùå
await waitFor(() => {})
expect(window.fetch).toHaveBeenCalledWith('foo')
expect(window.fetch).toHaveBeenCalledTimes(1)

// ‚úÖ
await waitFor(() => expect(window.fetch).toHaveBeenCalledWith('foo'))
expect(window.fetch).toHaveBeenCalledTimes(1)
```

The purpose of `waitFor` is to allow you to wait for a specific thing to happen.
If you pass an empty callback it _might_ work today because all you need to wait
for is "one tick of the event loop" thanks to the way your mocks work. But
you'll be left with a fragile test which could easily fail if you refactor your
async logic.

**Conselho: wait for a specific assertion inside `waitFor`.**

<br />

## Having multiple assertions in a single `waitFor` callback

> Import√¢ncia: baixa

```javascript
// ‚ùå
await waitFor(() => {
  expect(window.fetch).toHaveBeenCalledWith('foo')
  expect(window.fetch).toHaveBeenCalledTimes(1)
})

// ‚úÖ
await waitFor(() => expect(window.fetch).toHaveBeenCalledWith('foo'))
expect(window.fetch).toHaveBeenCalledTimes(1)
```

Let's say that for the example above, `window.fetch` was called twice. So the
`waitFor` call will fail, however, we'll have to wait for the timeout before we
see that test failure. By putting a single assertion in there, we can both wait
for the UI to settle to the state we want to assert on, and also fail faster if
one of the assertions do end up failing.

**Conselho: only put one assertion in a callback.**

<br />

## Performing side-effects in `waitFor`

> Import√¢ncia: alta

```javascript
// ‚ùå
await waitFor(() => {
  fireEvent.keyDown(input, {key: 'ArrowDown'})
  expect(screen.getAllByRole('listitem')).toHaveLength(3)
})

// ‚úÖ
fireEvent.keyDown(input, {key: 'ArrowDown'})
await waitFor(() => {
  expect(screen.getAllByRole('listitem')).toHaveLength(3)
})
```

`waitFor` is intended for things that have a non-deterministic amount of time
between the action you performed and the assertion passing. Because of this, the
callback can be called (or checked for errors) a non-deterministic number of
times and frequency (it's called both on an interval as well as when there are
DOM mutations). So this means that your side-effect could run multiple times!

This also means that you can't use snapshot assertions within `waitFor`. If you
do want to use a snapshot assertion, then first wait for a specific assertion,
and then after that you can take your snapshot.

**Conselho: put side-effects outside `waitFor` callbacks and reserve the callback

<br />
for assertions only.**

## Using `get*` variants as assertions

> Import√¢ncia: baixa

```javascript
// ‚ùå
screen.getByRole('alert', {name: /error/i})

// ‚úÖ
expect(screen.getByRole('alert', {name: /error/i})).toBeInTheDocument()
```

This one's not really a big deal actually, but I thought I'd mention it and give
my opinion on it. If `get*` queries are unsuccessful in finding the element,
they'll throw a really helpful error message that shows you the full DOM
structure (with syntax highlighting) which will help you during debugging.
Because of this, the assertion could never possibly fail (because the query will
throw before the assertion has a chance to).

For this reason, many people skip the assertion. This really is fine honestly,
but I personally normally keep the assertion in there just to communicate to
readers of the code that it's not just an old query hanging around after a
refactor but that I'm explicitly asserting that it exists.

**Conselho: If you want to assert that something exists, make that assertion

<br />
explicit.**

## Conclusion

As maintainers of the testing library family of tools, we do our best to make
APIs that lead people to use things as effectively as possible and where that
falls short we try to document things correctly. But this can be really
difficult (especially as APIs change/improve/etc). Hopefully this was helpful to
you. We really just want to make you more successful at shipping your software
with confidence.

Good luck!
